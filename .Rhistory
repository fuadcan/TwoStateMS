out <- optimizator()
return(out)
}
MSArfima.fit <- function(ser, type){
### Inputs
## ser is the series to fit
## type is the type of the algorithm, whether:
# (d,mu,sigma) state switching (type="DMS") or
# (d,mu)       state switching (type="DM")  or
# (d,sigma)    state switching (type="DS")  or
# (d)          state switching (type="D").
# Parameters
DLValgo  <- DLValgo[[type]]
pars     <- pars[[type]]
# Constraints
const_mat <- matrix(0,length(pars$lowerV),length(pars$lowerV))
diag(const_mat) <- 1
const_mat <- rbind(const_mat,-const_mat)
const_mat <- cbind(const_mat,c(pars$lowerV,-pars$upperV))
# Function for optimizing DLValgo
optimizator <- function(){
inits1  <- pars$inits1
temp1 <- constrOptim(inits1, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp1$convergence!=0){out <- temp1} else {
inits2 <- pars$inits2
temp2  <- constrOptim(inits2, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp2$convergence != 0) {out <- temp2} else {
inits3 <- pars$inits3
temp3  <- constrOptim(inits3, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp3$convergence != 0) {out <- temp3} else {
templist <- list(temp1,temp2,temp3)
lkls     <- sapply(templist, function(t) t$value)
out      <- templist[[which(min(lkls)==lkls)[1]]]
}
}
}
out <- optimizator()
return(out)
}
}
MSC
MSArfima.fit(ser,"DMS")
rm(ls=list())
rm(list=ls())
source('~/Documents/TwoStateMS/MSArfimaFit.R')
MSArfima.fit(ser,"DMS")
ser <- arima.sim(n = 63, list(ar = c(0.8897, -0.4858), ma = c(-0.2279, 0.2488)),
sd = sqrt(0.1796))
ser
c(ser)
ser <- c(ser)
ser
source("lnviD2.R")
source("lnviDM2.R")
source("lnviDSM2.R")
source("lnviDS2.R")
# Initial and Boundary Parameters
pars <- list(
DMS = list(lowerV = c(-2,-2,.8,.8,0.001,0.001,-5,-5),
upperV = c(2,2,.999,.999,5,5,5,5),
inits1 = c(1.2,  1.7,  0.9,  0.9,  0.01,0.01, 0.1,0.1),
inits2 = c(.8,  1.2,  0.9,  0.9,  0.01,0.01, 0.1,0.1),
inits3 = c(.5,  1,  0.9,  0.9,  0.01,0.01, 0.1,0.1)),
DM=list(lowerV = c(-2,-2,.8,.8,0.001,-5,-5),
upperV = c(2,2,.999,.999,5,5,5),
inits1 = c(1.2,  1.7,  0.9,  0.9,  0.01, 0.1,0.1),
inits2 = c(.8,  1.2,  0.9,  0.9,  0.01, 0.1,0.1),
inits3 = c(.5,  1,  0.9,  0.9,  0.01, 0.1,0.1)),
DS  = list(lowerV = c(-2,-2,.8,.8,0.001,0.001,-5),
upperV = c(2,2,.999,.999,5,5,5),
inits1 = c(1.2,  1.7,  0.9,  0.9,  0.01,0.01, 0.1),
inits2 = c(.8,  1.2,  0.9,  0.9,  0.01,0.01, 0.1),
inits3 = c(.5,  1,  0.9,  0.9,  0.01,0.01, 0.1)),
D  = list(lowerV = c(-2,-2,.8,.8,0.001,-5),
upperV = c(2,2,.999,.999,5,5),
inits1 = c(1.2,  1.7,  0.9,  0.9,  0.01, 0.1),
inits2 = c(.8,  1.2,  0.9,  0.9,  0.01, 0.1),
inits3 = c(.5,  1,  0.9,  0.9,  0.01, 0.1))
)
# Algorithms
DLValgo <- list(DMS=lnviDSM2,DM=lnviDM2,DS=lnviDS2,D=lnviD2)
MSArfima.fit <- function(ser, type){
### Inputs
## ser is the series to fit
## type is the type of the algorithm, whether:
# (d,mu,sigma) state switching (type="DMS") or
# (d,mu)       state switching (type="DM")  or
# (d,sigma)    state switching (type="DS")  or
# (d)          state switching (type="D").
# Parameters
DLValgo  <- DLValgo[[type]]
pars     <- pars[[type]]
# Constraints
const_mat <- matrix(0,length(pars$lowerV),length(pars$lowerV))
diag(const_mat) <- 1
const_mat <- rbind(const_mat,-const_mat)
const_mat <- cbind(const_mat,c(pars$lowerV,-pars$upperV))
# Function for optimizing DLValgo
optimizator <- function(){
inits1  <- pars$inits1
temp1 <- constrOptim(inits1, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp1$convergence!=0){out <- temp1} else {
inits2 <- pars$inits2
temp2  <- constrOptim(inits2, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp2$convergence != 0) {out <- temp2} else {
inits3 <- pars$inits3
temp3  <- constrOptim(inits3, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp3$convergence != 0) {out <- temp3} else {
templist <- list(temp1,temp2,temp3)
lkls     <- sapply(templist, function(t) t$value)
out      <- templist[[which(min(lkls)==lkls)[1]]]
}
}
}
out <- optimizator()
return(out)
}
}
# Parameters
DLValgo  <- DLValgo[[type]]
pars     <- pars[[type]]
type <- "DMS"
# Parameters
DLValgo  <- DLValgo[[type]]
pars     <- pars[[type]]
# Constraints
const_mat <- matrix(0,length(pars$lowerV),length(pars$lowerV))
diag(const_mat) <- 1
const_mat <- rbind(const_mat,-const_mat)
const_mat <- cbind(const_mat,c(pars$lowerV,-pars$upperV))
# Function for optimizing DLValgo
optimizator <- function(){
inits1  <- pars$inits1
temp1 <- constrOptim(inits1, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp1$convergence!=0){out <- temp1} else {
inits2 <- pars$inits2
temp2  <- constrOptim(inits2, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp2$convergence != 0) {out <- temp2} else {
inits3 <- pars$inits3
temp3  <- constrOptim(inits3, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp3$convergence != 0) {out <- temp3} else {
templist <- list(temp1,temp2,temp3)
lkls     <- sapply(templist, function(t) t$value)
out      <- templist[[which(min(lkls)==lkls)[1]]]
}
}
}
out <- optimizator()
return(out)
}
out <- optimizator()
ser <- arima.sim(n = 100, list(ar = c(0.8897, -0.4858), ma = c(-0.2279, 0.2488)),
sd = sqrt(0.1796))
type <- "DM"
source("lnviD2.R")
source("lnviDM2.R")
source("lnviDSM2.R")
source("lnviDS2.R")
# Initial and Boundary Parameters
pars <- list(
DMS = list(lowerV = c(-2,-2,.8,.8,0.001,0.001,-5,-5),
upperV = c(2,2,.999,.999,5,5,5,5),
inits1 = c(1.2,  1.7,  0.9,  0.9,  0.01,0.01, 0.1,0.1),
inits2 = c(.8,  1.2,  0.9,  0.9,  0.01,0.01, 0.1,0.1),
inits3 = c(.5,  1,  0.9,  0.9,  0.01,0.01, 0.1,0.1)),
DM=list(lowerV = c(-2,-2,.8,.8,0.001,-5,-5),
upperV = c(2,2,.999,.999,5,5,5),
inits1 = c(1.2,  1.7,  0.9,  0.9,  0.01, 0.1,0.1),
inits2 = c(.8,  1.2,  0.9,  0.9,  0.01, 0.1,0.1),
inits3 = c(.5,  1,  0.9,  0.9,  0.01, 0.1,0.1)),
DS  = list(lowerV = c(-2,-2,.8,.8,0.001,0.001,-5),
upperV = c(2,2,.999,.999,5,5,5),
inits1 = c(1.2,  1.7,  0.9,  0.9,  0.01,0.01, 0.1),
inits2 = c(.8,  1.2,  0.9,  0.9,  0.01,0.01, 0.1),
inits3 = c(.5,  1,  0.9,  0.9,  0.01,0.01, 0.1)),
D  = list(lowerV = c(-2,-2,.8,.8,0.001,-5),
upperV = c(2,2,.999,.999,5,5),
inits1 = c(1.2,  1.7,  0.9,  0.9,  0.01, 0.1),
inits2 = c(.8,  1.2,  0.9,  0.9,  0.01, 0.1),
inits3 = c(.5,  1,  0.9,  0.9,  0.01, 0.1))
)
# Algorithms
DLValgo <- list(DMS=lnviDSM2,DM=lnviDM2,DS=lnviDS2,D=lnviD2)
# Parameters
DLValgo  <- DLValgo[[type]]
pars     <- pars[[type]]
DLValgo
pars
# Constraints
const_mat <- matrix(0,length(pars$lowerV),length(pars$lowerV))
diag(const_mat) <- 1
const_mat <- rbind(const_mat,-const_mat)
const_mat <- cbind(const_mat,c(pars$lowerV,-pars$upperV))
inits1  <- pars$inits1
temp1 <- constrOptim(inits1, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
temp1
# Function for optimizing DLValgo
optimizator <- function(){
inits1  <- pars$inits1
temp1 <- constrOptim(inits1, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp1$convergence!=0){out <- temp1} else {
inits2 <- pars$inits2
temp2  <- constrOptim(inits2, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp2$convergence != 0) {out <- temp2} else {
inits3 <- pars$inits3
temp3  <- constrOptim(inits3, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp3$convergence != 0) {out <- temp3} else {
templist <- list(temp1,temp2,temp3)
lkls     <- sapply(templist, function(t) t$value)
out      <- templist[[which(min(lkls)==lkls)[1]]]
}
}
}
out <- optimizator()
return(out)
}
out <- optimizator()
if(temp1$convergence==0){out <- temp1} else {
inits2 <- pars$inits2
temp2  <- constrOptim(inits2, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp2$convergence == 0) {out <- temp2} else {
inits3 <- pars$inits3
temp3  <- constrOptim(inits3, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp3$convergence == 0) {out <- temp3} else {
templist <- list(temp1,temp2,temp3)
lkls     <- sapply(templist, function(t) t$value)
out      <- templist[[which(min(lkls)==lkls)[1]]]
}
}
}
out <- optimizator()
temp1 <- constrOptim(inits1, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
temp1$convergence==0
if(temp1$convergence==0){out <- temp1} else {
inits2 <- pars$inits2
temp2  <- constrOptim(inits2, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp2$convergence == 0) {out <- temp2} else {
inits3 <- pars$inits3
temp3  <- constrOptim(inits3, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp3$convergence == 0) {out <- temp3} else {
templist <- list(temp1,temp2,temp3)
lkls     <- sapply(templist, function(t) t$value)
out      <- templist[[which(min(lkls)==lkls)[1]]]
}
}
}
out
# Function for optimizing DLValgo
optimizator <- function(){
inits1  <- pars$inits1
cat(inits1)
temp1 <- constrOptim(inits1, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
cat(temp1$convergence)
if(temp1$convergence==0){out <- temp1} else {
inits2 <- pars$inits2
temp2  <- constrOptim(inits2, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp2$convergence == 0) {out <- temp2} else {
inits3 <- pars$inits3
temp3  <- constrOptim(inits3, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp3$convergence == 0) {out <- temp3} else {
templist <- list(temp1,temp2,temp3)
lkls     <- sapply(templist, function(t) t$value)
out      <- templist[[which(min(lkls)==lkls)[1]]]
}
}
}
out <- optimizator()
return(out)
}
out <- optimizator()
# Function for optimizing DLValgo
optimizator <- function(){
inits1  <- pars$inits1
cat(inits1)
temp1 <- constrOptim(inits1, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
cat(temp1$convergence)
if(temp1$convergence==0){out <- temp1} else {
inits2 <- pars$inits2
temp2  <- constrOptim(inits2, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp2$convergence == 0) {out <- temp2} else {
inits3 <- pars$inits3
temp3  <- constrOptim(inits3, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp3$convergence == 0) {out <- temp3} else {
templist <- list(temp1,temp2,temp3)
lkls     <- sapply(templist, function(t) t$value)
out      <- templist[[which(min(lkls)==lkls)[1]]]
}
}
}
return(out)
}
out <- optimizator()
out
MSArfima.fit <- function(ser, type){
### Inputs
## ser is the series to fit
## type is the type of the algorithm, whether:
# (d,mu,sigma) state switching (type="DMS") or
# (d,mu)       state switching (type="DM")  or
# (d,sigma)    state switching (type="DS")  or
# (d)          state switching (type="D").
# Parameters
DLValgo  <- DLValgo[[type]]
pars     <- pars[[type]]
# Constraints
const_mat <- matrix(0,length(pars$lowerV),length(pars$lowerV))
diag(const_mat) <- 1
const_mat <- rbind(const_mat,-const_mat)
const_mat <- cbind(const_mat,c(pars$lowerV,-pars$upperV))
# Function for optimizing DLValgo
optimizator <- function(){
inits1  <- pars$inits1
cat(inits1)
temp1 <- constrOptim(inits1, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
cat(temp1$convergence)
if(temp1$convergence==0){out <- temp1} else {
inits2 <- pars$inits2
temp2  <- constrOptim(inits2, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp2$convergence == 0) {out <- temp2} else {
inits3 <- pars$inits3
temp3  <- constrOptim(inits3, function(p) -DLValgo(p,ser), NULL, ui = const_mat[,-ncol(const_mat)], const_mat[,ncol(const_mat)])
if(temp3$convergence == 0) {out <- temp3} else {
templist <- list(temp1,temp2,temp3)
lkls     <- sapply(templist, function(t) t$value)
out      <- templist[[which(min(lkls)==lkls)[1]]]
}
}
}
return(out)
}
optPars <- optimizator()
optPars
}
optimizator(ser,"DMS")
MSArfima.fit(ser,"DSM")
MSArfima.fit(ser,"DMS")
MSArfima.fit(ser,"DM")
source('~/Documents/TwoStateMS/MSArfimaFit.R')
MSArfima.fit(ser,"DM")
MSArfima.fit(ser,"DMS")
source('~/Documents/TwoStateMS/MSArfimaFit.R')
MSArfima.fit(ser,"D")
source('~/Documents/TwoStateMS/dlvPath.R')
source('~/Documents/TwoStateMS/dlvPath.R')
opt <- MSArfima.fit(ser,"D")
res <- opt
res
source('~/Documents/TwoStateMS/MSArfimaFit.R')
dlvPath_d(opt$par,ser)
ser <- arima.sim(n = 100, list(ar = c(0.8897, -0.4858), ma = c(-0.2279, 0.2488)),
sd = sqrt(0.1796))
opt <- MSArfima.fit(ser,"D")
dlvPath_d(opt,ser)
opt
opt <- MSArfima.fit(ser,"D")
dlvPath_d(opt$par,ser)
opt$par
path * opt$par[1:2]
path <- dlvPath_d(opt$par,ser)
path * opt$par[1:2]
path
opt$par[1:2] * path
opt$par[1:2]
opt$par[1:2] %*% path
plot(opt$par[1:2] %*% path)
opt$par[1:2] %*% path
dplot <- opt$par[1:2] %*% path
dplot
plot(dplot)
dplot <- c(opt$par[1:2] %*% path)
plot(dplot)
plot(dplot, type='l')
## only d and mu switch states
opt  <- MSArfima.fit(ser,"DM")
path <- dlvPath_d(opt$par,ser)
path
ts.sim <- arima.sim(list(order = c(1,1,0), ar = 0.7), n = 200)
ts.plot(ts.sim)
ts.sim <- arima.sim(list(order = c(0,1,0), ar = 0.7), n = 200)
ts.plot(ts.sim)
ts.sim <- arima.sim(list(order = c(0,1,0)), n = 200)
ts.plot(ts.sim)
ts.sim <- arima.sim(list(order = c(0,0,0)), n = 200)
ts.plot(ts.sim)
ts.sim_p1 <- arima.sim(list(order = c(0,0,0)), n = 100)
ts.sim_p1 <- arima.sim(list(order = c(0,0,0)), n = 100)
ts.sim_p2 <- arima.sim(list(order = c(0,1,0)), n = 100)
ts.sim_p2
ser <- arima.sim(n = 100, list(ar = c(0.8897, -0.4858), ma = c(-0.2279, 0.2488)),
sd = sqrt(0.1796))
ser
ser <- c(ts.sim_p1,ts.sim_p2)
ser
ts.sim_p1 <- arima.sim(list(order = c(0,0,0)), n = 100)
ts.sim_p2 <- arima.sim(list(order = c(0,1,0)), n = 100)
ser <- c(ts.sim_p1,ts.sim_p2)
ser
ts.sim_p1
ts.sim_p2
ts.sim_p2 <- arima.sim(list(order = c(0,1,0)), n = 100)[-1]
ts.sim_p2
ser <- c(ts.sim_p1,ts.sim_p2)
ts.sim_p1 <- arima.sim(list(order = c(0,0,0)), n = 100)
ts.sim_p2 <- arima.sim(list(order = c(0,1,0)), n = 100)[-1]
ser <- c(ts.sim_p1,ts.sim_p2)
## only d switch states
opt  <- MSArfima.fit(ser,"D")
path <- dlvPath_d(opt$par,ser)
dplot <- c(opt$par[1:2] %*% path)
plot(dplot, type='l')
ser
plot(ser)
plot(dplot, type='l')
opt  <- MSArfima.fit(ser,"DM")
path <- dlvPath_d(opt$par,ser)
dplot <- c(opt$par[1:2] %*% path)
plot(dplot, type='l')
opt
## only d and sigma switch states
opt  <- MSArfima.fit(ser,"DM")
## only d and sigma switch states
opt  <- MSArfima.fit(ser,"DS")
path <- dlvPath_d(opt$par,ser)
dplot <- c(opt$par[1:2] %*% path)
plot(dplot, type='l')
## only d and mu switch states
opt  <- MSArfima.fit(ser,"DM")
path <- dlvPath_dm(opt$par,ser)
dplot <- c(opt$par[1:2] %*% path)
plot(dplot, type='l')
path
opt
opt_dm <- opt
## only d and sigma switch states
opt  <- MSArfima.fit(ser,"DS")
opt
cbind(opt,opt_dm)
cbind(opt$par,opt_dm$par)
## d, sigma and mu switch states
opt  <- MSArfima.fit(ser,"DSM")
## d, sigma and mu switch states
opt  <- MSArfima.fit(ser,"DMS")
opt
path <- dlvPath_dsm(opt$par,ser)
path
dplot <- c(opt$par[1:2] %*% path)
path
dat <- read.csv("data/madisonFrom-1930.csv")
dat
dat <- read.csv("data/madisonFrom-1930.csv",sep=";")
dat
combn(ncol(dat),2)
apply(combn(ncol(dat),2)),2,sum)
apply(combn(ncol(dat),2),2,sum)
dat
pdat <- apply(combn(ncol(dat),2),2,function(c) dat[c[1]]-dat[c[2]])
dat  <- read.csv("data/madisonFrom-1930.csv",sep=";")
dat  <- log(dat)
pdat <- apply(combn(ncol(dat),2),2,function(c) dat[c[1]]-dat[c[2]])
pdat
dat
log(dat
log(dat
dat
dat  <- read.csv("data/madisonFrom-1930.csv",sep=";")
dat  <- log(dat)
dat
dim(pdat)
combn(ncol(dat),2)
cc <- combn(ncol(dat),2)
cc[,1]
cc[,1]
2
cc[,1]
cc[,2]
pdat <- apply(combn(ncol(dat),2),2,function(c) dat[,c[1]]-dat[,c[2]] )
pdat
ser <- pdat[,1]
opt  <- MSArfima.fit(ser,"D")
path <- dlvPath_d(opt$par,ser)
dplot <- c(opt$par[1:2] %*% path)
plot(dplot, type='l')
colnames(dat)
combn(colnames(dat),2)
pnames <- apply(combn(ncol(dat),2),2,function(c) paste0(colnames(dat)[c[1]],"-",colnames(dat)[c[2]] ))
pnames
colnames(pdat) <- pnames
ser <- pdat[,1]
ser
## only d switch states
opt  <- MSArfima.fit(ser,"D")
path <- dlvPath_d(opt$par,ser)
dplot <- c(opt$par[1:2] %*% path)
axis(1, xaxp=c(10, 200, 19), las=2)
plot(1930:2010, dplot, type='l')
title(pnames[1])
opt  <- MSArfima.fit(ser,"DM")
path <- dlvPath_dm(opt$par,ser)
dplot <- c(opt$par[1:2] %*% path)
plot(1930:2010, dplot, type='l')
title(pnames[1])
axis(1, xaxp=c(10, 200, 19), las=2)
seq(1930,1930+nrow(dat)-1)
sername <- pnames[1]
yearrange <- seq(1930,1930+nrow(dat)-1)
# Log differences of each pair
pdat <- apply(combn(ncol(dat),2),2,function(c) dat[,c[1]]-dat[,c[2]] )
pnames <- apply(combn(ncol(dat),2),2,function(c) paste0(colnames(dat)[c[1]],"-",colnames(dat)[c[2]] )
pnames <- apply(combn(ncol(dat),2),2,function(c) paste0(colnames(dat)[c[1]],"-",colnames(dat)[c[2]] ))
pnames <- apply(combn(ncol(dat),2),2,function(c) paste0(colnames(dat)[c[1]],"-",colnames(dat)[c[2]] ))
colnames(pdat) <- pnames
title(sername)
